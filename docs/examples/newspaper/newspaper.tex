\documentclass[custom, plainsections]{sciposter}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Modify paper size and font size in papercustom.cfg in your tex install
% e.g. something like:
%  /usr/local/texlive/2010/texmf-dist/tex/latex/sciposter/papercustom.cfg
%  /usr/share/texmf-texlive/tex/latex/sciposter/papercustom.cfg
%
%\renewcommand{\papertype}{custom}
%\renewcommand{\fontpointsize}{14pt}
%\setlength{\paperwidth}{28.9cm}
%\setlength{\paperheight}{38.0cm}
%\renewcommand{\setpspagesize}{
%  \ifthenelse{\equal{\orientation}{portrait}}{
%    \special{papersize=28.9cm,38.0cm}
%    }{\special{papersize=38.0cm,28.9cm}
%    }
%  }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[ascii]{inputenc}
\usepackage[greek, english]{babel}
\usepackage[pdftex]{graphicx}
\usepackage{color}
\usepackage[small, numbered]{cwpuzzle}
\usepackage{multicol}
\usepackage{hyperref}

\usepackage{fancyvrb}
\fvset{fontsize=\tiny} % have code extracts be in smaller font size

\setlength\columnseprule{0.2pt}

<< pygments['bw.tex'] >>

\renewcommand{\rmdefault}{ptm}
\newcommand{\megasize}{\fontsize{100pt}{20pt}\selectfont}

\setmargins[0.6in]

\pagenumbering{arabic}

\title{Dexy News}
\author{Ana Nelson}
\begin{document}
\rmfamily

\begin{megasize}
\includegraphics{dexy--logo.pdf}
\hspace{0.1in}
Dexy News
\end{megasize} \hfill February 2012

\begin{multicols*}{3}

\small

\PARstart{P}{itchlift.org} lets you practice your elevator pitch and listen to other people's any time, from any telephone, even your land line. You can phone pitchlift right now on << PHONE_NUMBER >>. In this newspaper we will document how the Tropo API was used to create the pitchlift app.

\vspace{0.5cm}
\hrule
\Large
\begin{center}
\vspace{0.2cm}
<< PHONE_NUMBER >>
\end{center}
\small
\hrule

\vspace{1cm}

\PARstart{T}{ropo} is a powerful yet simple API that adds Voice and SMS support to the programming languages you already know.

\vspace{0.7cm}
\includegraphics[width=3in]{dexy--tropo-logo-new-wide.png}
\vspace{0.5cm}

\PARstart{I}{f} you can create a web site, you can make and receive phone calls, use voice recognition, interact via SMS. You can even create conference calls and transcribe calls. There's no need to learn new languages, wrestle with VoIP software, or learn about telephony. Host your code with Tropo, or use your existing web server in the language of your choice.

\PARstart{T}{ropo} adds a few simple communications commands to your favorite programming languages. Tropo makes it simple to build phone and SMS applications.  You use the web technologies you already know and Tropo's powerful cloud API to bring real-time communications to your apps.

\PARstart{R}{eady} to start coding? We've got lots of step by step quickstarts. Dive in with introductions on calling a phone number or accepting a call, sending text messages, receiving text through SMS, and transferring and rejecting calls. Want to do more? We have lots of tutorials available. If diving into sample code is more your thing, we've got sample apps in PHP, Ruby, Python, Groovy, and Javascript. Dig through the code for a voicemail system (complete with transcription), a weather forecast, or a local restaurant search that works over the phone and SMS. Call our demo numbers or try the code for yourself.

Here's a simple Tropo app that works via voice and SMS:

\fvset{fontsize=\small} % use small just this time
<< d['easy.js|pyg|l'] >>
\fvset{fontsize=\tiny}

Phone or send an SMS to:

\Large
\begin{center}
+1 (240) 242-7909
\end{center}
\small

\vspace{1cm}

\PARstart{D}{exy} is a free-form literate documentation tool for writing any kind of technical document incorporating code. Dexy helps you write correct documents, and to easily maintain them over time as your code changes. This newspaper was created using Dexy.

\large
\begin{center}
\href{http://bit.ly/xCJXxJ}{http://dexy.it}
\end{center}
\small

\PARstart{D}{exy} lets you get more out of the documentation tools you already use, and lets you write documentation in any text-based format. Dexy can interact with APIs to make publishing your output to wikis and blogs a snap. Dexy is also a powerful tool for reproducible scientific research, allowing calculations and plots to be embedded in documents while preserving provenance. Unlike some literate programming tools, Dexy does not restrict you to writing code in special sections of your documents using clunky tags, instead you can pull code into your documents from source code files in your local file system, in a git repository, or even sometimes from installed packages. So you are documenting real, working code. It's also easy to use the same example code in multiple documents, such as an article, a blog post and presentation slides, saving you time and giving your documentation a professional consistency.

\PARstart{W}{ith} Dexy you can document any programming language, and as many different languages as you want, even in a single document. So, you can use the same tool across all your different software projects. You can show raw source code, apply syntax highlighting to it, or show the output from actually running the code. Dexy can manage filenames for graphs generated by your code. It can even be used to take screenshots of a running web application, and to tie this in with your source code, integration tests and seed data.

\PARstart{T}{o} get started, you can work through the tutorials at \href{http://bit.ly/zj8iAj}{http://dexy.it/docs/tutorials}, and read more in-depth information in the online guide at \href{http://bit.ly/xloDcF}{http://dexy.it/docs/guide}. You can get in touch on twitter @dexyit. The rest of this document gives examples of Dexy including an interactive telephony app, Read on to see how the app was built, and then you can phone it on << PHONE_NUMBER >> or browse the web interface at \href{http://bit.ly/xOt1qs}{http://pitchlift.org}, and you can come chat with @Pitchlift on twitter.

This newspaper was typeset in \LaTeX~using the sciposter document class. You can see the preamble later in this document, and all source code is available online at \href{http://bit.ly/xbGpcN}{http://bit.ly/xbGpcN}

\vspace{5cm}

\PARstart{D}{exy} lets you continue to use your favorite documentation tools, while getting more out of them than ever, and being able to combine them in new and powerful ways. With Dexy you can bring your scripting and testing skills into play in your documentation, bringing project automation and integration to new level.

\vspace{0.5cm}
\hrule
\vspace{0.2cm}

\textbf{Contents}

Automating Screenshots with Dexy \dotfill \pageref{sec:automating-screenshots}

Multiple Programming Languages \dotfill \pageref{sec:multiple-languages}

Pitchlift 1 (Tropo Scripting App) \dotfill \pageref{sec:pitchlift-1}

Pitchlift 2 (Tropo WebAPI App) \dotfill \pageref{sec:pitchlift-2}

Audio Example \dotfill \pageref{sec:audio-example}

Ways to Present Code \dotfill \pageref{sec:present-code}

Crossword Solution \dotfill \pageref{sec:solution}

Source of This Newspaper \dotfill \pageref{sec:source}

\vspace{0.4cm}
\hrule
\vspace{0.4cm}

\large
Tropo Crossword Puzzle
\small

\vspace{0.4cm}

\textbf{Across}
1. distributed version control system
2. connecting two or more calls together
3. with Tropo scripting, Tropo can \_\_\_\_ your files
4. Representational State Transfer
5. sound that programmers make when completing their first Tropo hello, world
6. JQuery-based softphone
7. male british english voice name
8. sending a call to another number

\vspace{0.4cm}

\textbf{Down}
1. female australian english voice name
2. converting spoken words to text
3. ending a call
4. popular object-oriented programming language from Japan
5. cost of Tropo to developers
6. a place to post code for review
7. returns a busy signal
8. result of dividing by 0

\vspace{1.5cm}

\begin{Puzzle}{12}{13}%
|*|[1]g|i|[2]t|*|*|*|*|*|*|*|*|.
|*|r|*|[4]r|e|s|t|*|[3]h|o|s|t|.
|*|a|*|a|*|*|*|*|a|*|*|*|.
|*|[2]c|o|n|f|e|[4]r|e|n|c|e|*|.
|*|e|*|s|*|*|u|*|g|*|*|[5]f|.
|*|*|*|c|*|*|b|*|u|*|*|r|.
|*|*|*|r|*|*|[5]y|i|p|[6]p|e|e|.
|[7]r|*|*|i|*|*|*|*|*|a|*|e|.
|e|*|*|[6]p|h|o|[8]n|o|*|s|*|*|.
|j|*|*|t|*|*|a|*|*|t|*|*|.
|e|*|[7]s|i|m|o|n|*|*|i|*|*|.
|c|*|*|o|*|*|*|*|*|e|*|*|.
|[8]t|r|a|n|s|f|e|r|*|*|*|*|.
\end{Puzzle}

\end{multicols*}

\pagebreak

\begin{multicols*}{2}
\small

\large
Automating Screenshots with Dexy
\small

\label{sec:automating-screenshots}

\vspace{5pt}

\PARstart{A}{ fun} and useful thing to automate with Dexy is taking screenshots of your web application and incorporating them into your documentation. Screenshots are useful in installation guides (to show a picture of what it should look like when successfully installed and started), in end-user documentation, and also in developer documentation. Combining automated screenshots with integration testing is a very powerful approach which will save lots of time in the long run.

\PARstart{I}{n} this example we will look at a simple web.py web application and show how you can automate taking screenshots using selenium and firefox. We want to automate this so it can run on a remote server as part of an automated build, so the first thing we will need is to set up a virtual display. The Xvfb virtual framebuffer acts like an X11 display so programs (like firefox) which expect a display will be able to run, and we can capture screenshots of what has been rendered. On Ubuntu we install Xvfb like this:

<< d['/install/full-setup-ubuntu.sh|idio|l']['virtual-display'] >>

And we run it like this, setting the DISPLAY variable correspondingly:

<< d['/install/dexy-site-environment.sh|idio|l']['virtual-display'] >>

We download the standalone selenium server and start it, this is what will allow us to automate firefox:

<< d['/install/dexy-site-environment.sh|idio|l']['start-selenium'] >>

Next we install some software needed for running our web application:

<< d['/install/full-setup-ubuntu.sh|idio|l']['webpy-installs'] >>

The web.py framework includes some tools for working with databases, we will use a simple sqlite3 database. Here is the schema:
<< d['/docs/examples/webpy/schema.sql|pyg|l'] >>

We load the schema into a database and start the web.py server:
<< d['/install/dexy-site-environment.sh|idio|l']['start-webpy'] >>

Now that we are set up, we can run our code and take screenshots:
<< d['/docs/examples/webpy/take-screenshots.py|idio|l']['imports'] >>

This script is in Python and it uses a Python package for interacting with selenium, which we installed earlier using pip. We define a helper method to make it easy to take screenshots:
<< d['/docs/examples/webpy/take-screenshots.py|idio|l']['screencapture'] >>

Now we launch an instance of firefox:
<< d['/docs/examples/webpy/take-screenshots.py|idio|l']['start-browser'] >>

Then, we simply load the home page of our web.py app:
<< d['/docs/examples/webpy/take-screenshots.py|idio|l']['load-index-page'] >>

Here is the first screenshot:

\includegraphics[width=5in]{<< a['/docs/examples/webpy/index.png'].filename() >>}

\vspace{3cm}

The template for this page is:
<< d['/docs/examples/webpy/templates/index.html|pyg|l'] >>

Next we will start entering a to-do item:
<< d['/docs/examples/webpy/take-screenshots.py|idio|l']['enter-text'] >>

We can show the user what this will look like:

\includegraphics[width=5in]{<< a['/docs/examples/webpy/enter.png'].filename() >>}

Now we click the "Add todo" button to actually create the todo:

<< d['/docs/examples/webpy/take-screenshots.py|idio|l']['add-todo'] >>

\includegraphics[width=5in]{<< a['/docs/examples/webpy/add.png'].filename() >>}

We can check this by:

<< d['/docs/examples/webpy/take-screenshots.py|idio|l']['check-todo-added'] >>

An exception is raised if this is not found:

<< d['/docs/examples/webpy/take-screenshots.py|idio|l']['show-exception'] >>

Here is the output when we run this script, showing that the NoSuchElementException was raised:
\begin{Verbatim}
<< d['/docs/examples/webpy/take-screenshots.py|fn|py'] >>
\end{Verbatim}

As in this example, we can simply look for the content that we know should exist on the page and raise an exception if it is not found. This approach can also be formalized by using a testing framework, or a BDD framework such as cucumber. With this approach, your screenshots are backed by tests, so you know that every screenshot in your user guide or developer docs has tested assertions backing it up. Having automated screenshots means that it is easy to update them when your code changes, and it is easy to generate screenshots for different branding of your application, ideal if you have a white label product and wish to give your users personalized documentation. To finish up, we will delete the todo we created:

<< d['/docs/examples/webpy/take-screenshots.py|idio|l']['delete-todo'] >>

\includegraphics[width=5in]{<< a['/docs/examples/webpy/delete.png'].filename() >>}

\pagebreak

\large
Multiple Programming Languages
\small

\vspace{5pt}

\label{sec:multiple-languages}
\PARstart{D}{exy} lets you document multiple programming languages in a single document, so let's look at a simple Tropo voicemail application scripting example in Javascript, Ruby, PHP, Python and Groovy.

Voicemail with transcription sounds like a potentially lengthy, complicated application - you'll need to answer a call, prompt the user for their message, give them a tone to indicate when to start speaking, send the call somewhere for transcription...lots of steps that often have lots of sub-steps. Tropo aims to take all of that, wrap it up behind the scenes and give you working code with just a few easy methods.

The following example handles everything mentioned earlier, plus defines time constraints - 10 seconds without any talking and the app will end, 7 seconds after someone stops talking the app will end, and the caller gets cut off at 60 seconds no matter what. It also adds a terminator for the user to end the recording; if the caller uses it, Tropo will play their recording back to them before disconnecting. The recording is then sent off to the URL defined with transcription right behind it:

\vspace{10pt}

\textbf{Javascript:}

<< d['voicemail.js|pyg|l'] >>

\textbf{Ruby:}

<< d['voicemail.rb|pyg|l'] >>

\textbf{PHP:}

<< d['voicemail.php|pyg|l'] >>

\textbf{Python:}

<< d['voicemail.py|pyg|l'] >>

\textbf{Groovy:}

<< d['voicemail.groovy|pyg|l'] >>

\large
Pitchlift 1 Source Code
\small

\label{sec:pitchlift-1}

\vspace{5pt}

\PARstart{T}{o} start developing pitchlift, we wrote a basic Tropo scripting application. There are two ways to develop Tropo applications, via direct scripting or via calls to the web API. The web API is more flexible, but scripting can be simpler to get started with and in some cases, it's all you need.

The first pitchlift application presents you with a menu of 2 choices, you can create a new pitch or listen to pitches that have been recorded by other people.

Here is how we record a new pitch. To start with, we create a pitch id which we will save the pitch under, and also a PIN which the caller can use later to manage their pitch. We also take note of the caller ID:

<< d['pitchlift.rb|idio|l']['do-record'] >>

Here is the code we use to create a random pitch ID and check that it is unique (not the best code, but we'll improve it later):

<< d['pitchlift.rb|idio|l']['random-pitch-id'] >>

And here is the code to create a random PIN:

<< d['pitchlift.rb|idio|l']['random-pin'] >>

To check for a valid caller id, we make sure this call is coming from a SIP phone and the caller ID is a number (maybe starting with plus):

<< d['pitchlift.rb|idio|l']['is-valid-caller-id'] >>

Next, we give our caller some instructions so they know what to expect:

<< d['pitchlift.rb|idio|l']['recording-instructions'] >>

And now we are ready to actually record:

<< d['pitchlift.rb|idio|l']['record-pitch'] >>

\pagebreak

\large
Tropo Web API
\small

\vspace{5pt}

\PARstart{T}{he} Tropo Web API lets you integrate telephone and SMS with a web application. We will use the Tropo Web API to make a more advanced version of our pitchlift app with a web interface. Here is a Hello, World for Tropo's Web API using the tropo-webapi-python library and the web.py web application framework:

<< d['pitchlift-2/hello.py|pyg|l'] >>

The Tropo library in Python helps us generate the JSON which Tropo reads when it contacts this application for instructions. We can see this JSON by accessing this URL directly using cURL:

<< d['pitchlift-2/curl-hello.sh|pyg|l'] >>

Here is the JSON output that Tropo will see and use to handle the call:

\begin{Verbatim}
<< d['pitchlift-2/curl-hello.sh|sh'] >>
\end{Verbatim}

\vspace{10pt}

\large
Pitchlift 2 Source Code
\small

\label{sec:pitchlift-2}

\vspace{5pt}

\PARstart{F}{or} our real pitchlift application, we want to have a web interface as well as Tropo interaction. We will use the web.py framework to create a web application which will use JSON to communicate with Tropo to handle calls, and also render HTML for people to browse. We will also use a sqlite database to store information about pitches. Here is the schema for our sqlite database:
<< d['pitchlift-2/schema.sql|pyg|l'] >>

When a call is first relayed, important metadata such as the caller id, caller network (e.g. SIP/telephones, Skype), and caller channel (e.g. voice or sms) are passed to our app, so we make sure to store this information for later use:
<< d['pitchlift-2/pitchlift2.py|idio|l']['main-menu-initial'] >>

Then we proceed to the code for the main menu, which is going to read out available options to the caller:
<< d['pitchlift-2/pitchlift2.py|idio|l']['main-menu-index'] >>

We can use cURL to view the main menu options as Tropo sees them:
<< d['pitchlift-2/curl-pitchlift.sh|pyg|l'] >>

Here is the JSON:

<< d['pitchlift-2/curl-pitchlift.sh|sh|ppjson|pyg|l'] >>

Then we handle the user's response and pass them on to the appropriate method:
<< d['pitchlift-2/pitchlift2.py|idio|l']['main-menu-cont'] >>

The \verb|get_answer| helper method automatically parses the information from Tropo and returns the value chosen by the caller:
<< d['pitchlift-2/pitchlift2.py|idio|l']['get-answer'] >>

Let's see how a new pitch is recorded. The \verb|do_pitch| method starts by generating a random pitch ID, a PIN to allow people to manage their pitches later, and a key which will be used behind the scenes to transfer data:
<< d['pitchlift-2/pitchlift2.py|idio|l']['do-pitch'] >>

Next we give some verbal instructions to help the caller know what's about to happen:
<< d['pitchlift-2/pitchlift2.py|idio|l']['recording-instructions'] >>

Then we actually record the call, passing callback URLs to Tropo to receive the recording and the transcription:
<< d['pitchlift-2/pitchlift2.py|idio|l']['make-recording'] >>

Finally we tell Tropo what URL has the instructions for what to do with the caller after the recording is complete:
<< d['pitchlift-2/pitchlift2.py|idio|l']['finish'] >>

The recorded \verb|.wav| file is uploaded to Amazon S3:

<< d['pitchlift-2/pitchlift2.py|idio|l']['record-pitch-tropo'] >>

And a transcription will be generated and stored in the database:

<< d['pitchlift-2/pitchlift2.py|idio|l']['transcription-tropo'] >>

Our callback method reads the recorded pitch back to the user, and asks them to specify whether they are happy with it, or would like to delete it and redo:

<< d['pitchlift-2/pitchlift2.py|idio|l']['after-record-pitch-tropo'] >>

Assuming they are happy, the 'confirmed' state of the pitch is recorded in the database and the caller is read their pitch ID and pin number for managing their pitch (this information will also be sent by SMS if possible):

<< d['pitchlift-2/pitchlift2.py|idio|l']['do-happy'] >>

That's all for recording pitches! If someone wants to listen to a pitch, they will be asked whether they want to listen to a random pitch or enter a pitch ID:

<< d['pitchlift-2/pitchlift2.py|idio|l']['do-listen'] >>

<< d['pitchlift-2/pitchlift2.py|idio|l']['listen'] >>

The \verb|random_pitch| method chooses a pitch from among the confirmed pitches in the database:

<< d['pitchlift-2/pitch.py|idio|l']['random-pitch'] >>

The web.py framework provides database abstraction, so it's straightforward to define methods like \verb|get_pitches| which retrieves all confirmed pitches:

<< d['pitchlift-2/pitch.py|idio|l']['get-pitches'] >>

We can also use web.py's templating system to render HTML from a template, the controller code is very simple:

<< d['pitchlift-2/pitchlift2.py|idio|l']['index'] >>

And here is the HTML template:

<< d['pitchlift-2/templates/index.html|pyg|l'] >>

\pagebreak

\large
Audio Example
\small

\label{sec:audio-example}

\vspace{5pt}

Let's look at a different Dexy example now, this time using the R statistical programming language to play around with audio files.

Here is our \verb|.dexy| configuration file (see the tutorials at \href{http://bit.ly/zj8iAj}{http://dexy.it/docs/tutorials} to learn more about \verb|.dexy| files):

<< d['audio/.dexy|ppjson|pyg|l'] >>

Here is an artificial wave we construct:

<< d['audio/plot.R|fn|idio|rint|pyg|l']['code1'] >>

\includegraphics{dexy--audio/oscillo1.pdf}

Next, we create a .wav file by using espeak to convert this text:

\begin{Verbatim}
<< d['audio/pitch.txt'] >>
\end{Verbatim}

And then we read this file into R and create an oscillogram:

<< d['audio/plot.R|fn|idio|rint|pyg|l']['code2'] >>

\includegraphics{dexy--audio/oscillo2.pdf}

\large
Ways to Present Code
\small

\label{sec:present-code}

\vspace{5pt}

\PARstart{D}{exy} lets you put your code to use in many different ways. Let's look at a simple R script and see some different ways we can include it in a document. Here is the script:

\begin{Verbatim}
<< d['example.rb'] >>
\end{Verbatim}

This is the first way of including code, just include it! Next, let's add some syntax highlighting:

<< d['example.rb|pyg|l'] >>

That's not the most dramatic change because we're printing this in black and white (technicolor is so expensive!).

Now, let's actually run this code using Dexy! We can run it using the ruby command line tool, in which case we will just see what gets output:

\begin{Verbatim}
<< d['example.rb|rb'] >>
\end{Verbatim}

Or, we can use the irb REPL and then we can see both the input and output from running the script:

<< d['example.rb|irb|pyg|l'] >>

When writing tutorials or other documentation, it is often useful to be able to break the code into sections so you can explain more clearly what is happening in each step. This is easy to do in Dexy. First, we assign variables:

<< d['example.rb|idio|l']['assign-variables'] >>

Then we do a calculation:

<< d['example.rb|idio|l']['show-answer'] >>

We can also preserve these sections after running the code through an interpreter like the irb REPL. Again, first we assign variables:

<< d['example.rb|idio|irb|pyg|l']['assign-variables'] >>

Then we do a calculation:

<< d['example.rb|idio|irb|pyg|l']['show-answer'] >>

When writing your own documentation, you can choose whichever of these methods is the most appropriate. You can even have the code be entirely behind the scenes and just state that << d['example.rb|rb'] >>.

\pagebreak

\large
Crossword Puzzle Solution
\small

\label{sec:solution}

\vspace{0.5cm}

\PuzzleSolution
\begin{Puzzle}{12}{13}%
|*|[1]g|i|[2]t|*|*|*|*|*|*|*|*|.
|*|r|*|[4]r|e|s|t|*|[3]h|o|s|t|.
|*|a|*|a|*|*|*|*|a|*|*|*|.
|*|[2]c|o|n|f|e|[4]r|e|n|c|e|*|.
|*|e|*|s|*|*|u|*|g|*|*|[5]f|.
|*|*|*|c|*|*|b|*|u|*|*|r|.
|*|*|*|r|*|*|[5]y|i|p|[6]p|e|e|.
|[7]r|*|*|i|*|*|*|*|*|a|*|e|.
|e|*|*|[6]p|h|o|[8]n|o|*|s|*|*|.
|j|*|*|t|*|*|a|*|*|t|*|*|.
|e|*|[7]s|i|m|o|n|*|*|i|*|*|.
|c|*|*|o|*|*|*|*|*|e|*|*|.
|[8]t|r|a|n|s|f|e|r|*|*|*|*|.
\end{Puzzle}

\vspace{1cm}

\large
Source of This Newspaper
\small

\label{sec:source}

\vspace{5pt}

\PARstart{H}{ere} is the .dexy configuration file for the newspaper (this newspaper is part of the dexy website so it also inherits from .dexy files in parent directories):

<< d['.dexy|ppjson|pyg|l'] >>

\vspace{4cm}

~

\PARstart{T}{his} is the beginning of the .tex file containing the source for this newspaper. This shows you the \LaTeX~preamble and also some Jinja tags for including dynamic Dexy content. Full source code is available from http://github.com/ananelson/dexy-site/tree/master/docs/examples/newspaper or http://bit.ly/xbGpcN

<< d['newspaper.tex|wrap|pyg|l'][0:16934] >>
\end{Verbatim}

\end{multicols*}

\end{document}

